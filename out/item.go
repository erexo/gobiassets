package out

import (
	"fmt"
	"log"
	"math"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/erexo/gobiassets/in"
)

type Item struct {
	ServerId    uint16
	ClientId    uint16
	Name        string
	Type        ItemType
	Role        ItemRole
	Description string
	Weight      float32
	Worth       int64
	Attributes  Attributes
}

type ItemAttribute uint8

const (
	ItemAttributeAttack ItemAttribute = iota
	ItemAttributeRange
	ItemAttributeBreakChance
	ItemAttributeArmor
	ItemAttributeContainerSize
	ItemAttributeDuration
	ItemAttributeCharges
	ItemAttributeLevel

	ItemAttributeSpeed
	ItemAttributePreventDrop
	ItemAttributeReduceDeath
	ItemAttributeManaShield
	ItemAttributeMaxHealth
	ItemAttributeMaxHealthPercent
	ItemAttributeMaxMana
	ItemAttributeMaxManaPercent
	ItemAttributeHealthTicks
	ItemAttributeHealthGain
	ItemAttributeManaTicks
	ItemAttributeManaGain
	ItemAttributeSoul
	ItemAttributeSkillAll
	ItemAttributeSkillNinjutsu
	ItemAttributeSkillFuinjutsu
	ItemAttributeSkillBukijutsu
	ItemAttributeSkillTaijutsu
	ItemAttributeSkillSenjutsu
	ItemAttributeSkillGenjutsu
	ItemAttributeSkillVitality
	ItemAttributeSkillControl
	ItemAttributeMagicCritChance
	ItemAttributeMeleeCritChance
	ItemAttributeMagicPercent
	ItemAttributeMagicPvePercent
	ItemAttributeMeleePercent
	ItemAttributeHealingPercent
	ItemAttributeProtection
	ItemAttributeMagicCritDamage
	ItemAttributeMeleeCritDamage
)

func SaveItems(prices in.Prices) []*Item {
	defer LogTime("Items")()

	serverClient, clientServer := in.ReadOtb()

	input := in.ReadItems()
	itemsToInclude := make(map[uint16]struct{})

	// categories
	var categoriesStr strings.Builder
	for cat := ItemCategoryFirst; cat <= ItemCategoryLast; cat++ {
		categoriesStr.WriteString(fmt.Sprintf("\tItemCategory(%d): {", cat))
		if it, ok := Items[cat]; ok {
			if len(it) > 0 {
				categoriesStr.WriteByte('\n')
			}
			for _, id := range it {
				itemsToInclude[id] = struct{}{}

				categoriesStr.WriteString("\t\titem")
				categoriesStr.WriteString(strconv.Itoa(int(id)))
				categoriesStr.WriteString(",\n")
			}
			if len(it) > 0 {
				categoriesStr.WriteByte('\t')
			}
		}
		categoriesStr.WriteString("},\n")
	}

	items := make([]*Item, 0, len(input))
	for _, item := range input {
		if _, ok := itemsToInclude[uint16(item.Id)]; !ok {
			continue
		}
		if client, ok := serverClient[uint16(item.Id)]; ok {
			attrItem := item
			if equipTo := item.Attributes.Read("transformEquipTo"); equipTo != 0 {
				for _, it := range input {
					if it.Id == int(equipTo) {
						attrItem = it
						break
					}
				}
			}
			it := NewItem(client, item, attrItem)
			if it.Worth == 0 {
				if price, ok := prices[item.Id]; ok {
					it.Worth = int64(price)
				}
			}
			items = append(items, it)
		}
	}

	_ = os.MkdirAll(outputDir, 0755)
	f, err := os.OpenFile(path.Join(outputDir, itemsFileName), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	idChars := 1
	if len(items) > 0 {
		idChars += len(strconv.Itoa(int(items[len(items)-1].ServerId)))
	}

	var varStr strings.Builder
	var switchStr strings.Builder
	for _, item := range items {
		// var
		varName := fmt.Sprintf("item%d", item.ServerId)
		varStr.WriteByte('\t')
		varStr.WriteString(varName)
		nameDiff := idChars - len(strconv.Itoa(int(item.ServerId)))
		for i := 0; i < nameDiff; i++ {
			varStr.WriteByte(' ')
		}
		varStr.WriteString("= &")
		varStr.WriteString(item.String())
		varStr.WriteByte('\n')

		// switch
		switchStr.WriteString(fmt.Sprintf("\n\tcase %d:\n\t\treturn %s", item.ClientId, varName))
	}

	if _, err := fmt.Fprintf(f, `// Code generated by "gobiassets" using 'go generate'. DO NOT EDIT.

package %s

%s

%s

var (
%s)

var ItemsCategory = map[ItemCategory][]*Item{
%s}

func GetItem(clientId uint16) *Item {
	switch clientId {%s
	default:
		return nil
	}
}
`, packageName, ItemCategoryPrefix(), ItemHeader(), varStr.String(), categoriesStr.String(), switchStr.String()); err != nil {
		panic(err)
	}

	verifyClientId(items, input, clientServer)
	return items
}

type Attributes []byte

type AttributeValue struct {
	Attribute ItemAttribute
	Value     int32
}

const attSize = 5

func (w Attributes) ReadAttribute(attribute ItemAttribute) (int32, bool) {
	for i := 0; i+attSize <= len(w); i += attSize {
		if ItemAttribute(w[i]) == attribute {
			return int32(w[i+1]) |
				int32(w[i+2])<<8 |
				int32(w[i+3])<<16 |
				int32(w[i+4])<<24, true
		}
	}
	return 0, false
}

func (w Attributes) ReadAttributes() []AttributeValue {
	ret := []AttributeValue{}
	for i := 0; i+attSize <= len(w); i += attSize {
		ret = append(ret, AttributeValue{
			Attribute: ItemAttribute(w[i]),
			Value: int32(w[i+1]) |
				int32(w[i+2])<<8 |
				int32(w[i+3])<<16 |
				int32(w[i+4])<<24,
		})
	}
	return ret
}

func (w *Attributes) writeAttr(attr ItemAttribute, value int64) {
	if value == 0 {
		return
	}
	if value > math.MaxInt32 {
		panic("attribute bigger than int32")
	}

	*w = append(*w, uint8(attr),
		uint8(value),
		uint8(value>>8),
		uint8(value>>16),
		uint8(value>>24))
}

func NewItem(client uint16, item *in.Item, attrItem *in.Item) *Item {
	return &Item{
		ServerId:    uint16(item.Id),
		ClientId:    client,
		Name:        Title(item.Name),
		Type:        Type(item.Attributes.ReadString("itemType")),
		Role:        Role(item.Attributes.ReadString("role")),
		Description: item.Attributes.ReadString("description"),
		Weight:      float32(item.Attributes.Read("weight")) / 100,
		Worth:       item.Attributes.Read("worth"),
		Attributes:  getAttrs(attrItem),
	}
}

func getAttrs(item *in.Item) Attributes {
	attr := Attributes{}
	attr.writeAttr(ItemAttributeAttack, item.Attributes.Read("attack", "extraatk", "elementphysical", "elementfire", "elementenergy", "elementearth", "elementice", "elementholy", "elementdeath"))
	attr.writeAttr(ItemAttributeRange, item.Attributes.Read("range"))
	attr.writeAttr(ItemAttributeBreakChance, item.Attributes.Read("breakchance"))
	attr.writeAttr(ItemAttributeArmor, item.Attributes.Read("armor"))
	attr.writeAttr(ItemAttributeContainerSize, item.Attributes.Read("containersize"))
	attr.writeAttr(ItemAttributeDuration, item.Attributes.Read("duration"))
	attr.writeAttr(ItemAttributeCharges, item.Attributes.Read("charges"))
	attr.writeAttr(ItemAttributeLevel, item.Attributes.Read("level"))
	attr.writeAttr(ItemAttributeSpeed, item.Attributes.Read("speed"))
	attr.writeAttr(ItemAttributePreventDrop, item.Attributes.Read("preventdrop"))
	attr.writeAttr(ItemAttributeReduceDeath, item.Attributes.Read("reducedeathpercent"))
	attr.writeAttr(ItemAttributeManaShield, item.Attributes.Read("manashield"))
	attr.writeAttr(ItemAttributeMaxHealth, item.Attributes.Read("maxhealthpoints"))
	attr.writeAttr(ItemAttributeMaxHealthPercent, item.Attributes.ReadPercent("maxhealthpercent"))
	attr.writeAttr(ItemAttributeMaxMana, item.Attributes.Read("maxmanapoints"))
	attr.writeAttr(ItemAttributeMaxManaPercent, item.Attributes.ReadPercent("maxmanapercent"))
	attr.writeAttr(ItemAttributeHealthTicks, item.Attributes.Read("healthticks"))
	attr.writeAttr(ItemAttributeHealthGain, item.Attributes.Read("healthgain"))
	attr.writeAttr(ItemAttributeManaTicks, item.Attributes.Read("manaticks"))
	attr.writeAttr(ItemAttributeManaGain, item.Attributes.Read("managain"))
	attr.writeAttr(ItemAttributeSoul, item.Attributes.Read("soulpoints"))
	attr.writeAttr(ItemAttributeSkillAll, item.Attributes.Read("allskills"))
	attr.writeAttr(ItemAttributeSkillNinjutsu, item.Attributes.Read("ninjutsu"))
	attr.writeAttr(ItemAttributeSkillFuinjutsu, item.Attributes.Read("fuinjutsu"))
	attr.writeAttr(ItemAttributeSkillBukijutsu, item.Attributes.Read("bukijutsu"))
	attr.writeAttr(ItemAttributeSkillTaijutsu, item.Attributes.Read("taijutsu"))
	attr.writeAttr(ItemAttributeSkillSenjutsu, item.Attributes.Read("senjutsu"))
	attr.writeAttr(ItemAttributeSkillGenjutsu, item.Attributes.Read("genjutsu"))
	attr.writeAttr(ItemAttributeSkillVitality, item.Attributes.Read("vitality"))
	attr.writeAttr(ItemAttributeSkillControl, item.Attributes.Read("control"))
	attr.writeAttr(ItemAttributeMagicCritChance, item.Attributes.Read("magiccritchance"))
	attr.writeAttr(ItemAttributeMeleeCritChance, item.Attributes.Read("meleecritchance"))
	attr.writeAttr(ItemAttributeMagicPercent, item.Attributes.ReadPercent("increasemagicpercent"))
	attr.writeAttr(ItemAttributeMagicPvePercent, item.Attributes.ReadPercent("increasemagicpvepercent"))
	attr.writeAttr(ItemAttributeMeleePercent, item.Attributes.ReadPercent("increasemeleepercent"))
	attr.writeAttr(ItemAttributeHealingPercent, item.Attributes.ReadPercent("increasehealingpercent"))
	attr.writeAttr(ItemAttributeProtection, item.Attributes.Read("absorbpercentall"))
	attr.writeAttr(ItemAttributeMagicCritDamage, item.Attributes.Read("magiccritdamage"))
	attr.writeAttr(ItemAttributeMeleeCritDamage, item.Attributes.Read("meleecritdamage"))
	return attr
}

func ItemHeader() string {
	return `type Item struct {
	ServerId    uint16
	ClientId    uint16
	Name        string
	Type        ItemType
	Role        ItemRole
	Description string
	Weight      float32
	Worth       int64
	Attributes  Attributes
}

type ItemAttribute uint8

const (
	ItemAttributeAttack ItemAttribute = iota
	ItemAttributeRange
	ItemAttributeBreakChance
	ItemAttributeArmor
	ItemAttributeContainerSize
	ItemAttributeDuration
	ItemAttributeCharges
	ItemAttributeLevel

	ItemAttributeSpeed
	ItemAttributePreventDrop
	ItemAttributeReduceDeath
	ItemAttributeManaShield
	ItemAttributeMaxHealth
	ItemAttributeMaxHealthPercent
	ItemAttributeMaxMana
	ItemAttributeMaxManaPercent
	ItemAttributeHealthTicks
	ItemAttributeHealthGain
	ItemAttributeManaTicks
	ItemAttributeManaGain
	ItemAttributeSoul
	ItemAttributeSkillAll
	ItemAttributeSkillNinjutsu
	ItemAttributeSkillFuinjutsu
	ItemAttributeSkillBukijutsu
	ItemAttributeSkillTaijutsu
	ItemAttributeSkillSenjutsu
	ItemAttributeSkillGenjutsu
	ItemAttributeSkillVitality
	ItemAttributeSkillControl
	ItemAttributeMagicCritChance
	ItemAttributeMeleeCritChance
	ItemAttributeMagicPercent
	ItemAttributeMagicPvePercent
	ItemAttributeMeleePercent
	ItemAttributeHealingPercent
	ItemAttributeProtection
	ItemAttributeMagicCritDamage
	ItemAttributeMeleeCritDamage
)

type Attributes []byte

type AttributeValue struct {
	Attribute ItemAttribute
	Value     int32
}

const attSize = 5

func (w Attributes) ReadAttribute(attribute ItemAttribute) (int32, bool) {
	for i := 0; i+attSize <= len(w); i += attSize {
		if ItemAttribute(w[i]) == attribute {
			return int32(w[i+1]) |
				int32(w[i+2])<<8 |
				int32(w[i+3])<<16 |
				int32(w[i+4])<<24, true
		}
	}
	return 0, false
}

func (w Attributes) ReadAttributes() []AttributeValue {
	ret := []AttributeValue{}
	for i := 0; i+attSize <= len(w); i += attSize {
		ret = append(ret, AttributeValue{
			Attribute: ItemAttribute(w[i]),
			Value: int32(w[i+1]) |
				int32(w[i+2])<<8 |
				int32(w[i+3])<<16 |
				int32(w[i+4])<<24,
		})
	}
	return ret
}`
}

func (i *Item) String() string {
	var attrsStr strings.Builder
	if len(i.Attributes) == 0 {
		attrsStr.WriteString("nil")
	} else {
		attrsStr.WriteString("[]byte{")
		for j, v := range i.Attributes {
			attrsStr.WriteString(strconv.Itoa(int(v)))
			if j < len(i.Attributes)-1 {
				attrsStr.WriteString(", ")
			}
		}
		attrsStr.WriteByte('}')
	}
	return fmt.Sprintf(`Item{%d, %d, "%s", %d, %d, "%s", %.2f, %d, %s}`,
		i.ServerId, i.ClientId, i.Name, i.Type, i.Role, i.Description, i.Weight, i.Worth, attrsStr.String())
}
func verifyClientId(items []*Item, initems []*in.Item, clientServer in.ClientServerMap) {
	desired := make(map[uint16][]*in.Item)
	for _, item := range items {
		if servers, ok := clientServer[item.ClientId]; ok {
			srv := make([]*in.Item, 0, len(servers))
			for _, serverId := range servers {
				if serverId == item.ServerId {
					continue
				}
				for _, it := range initems {
					if it.Id == int(serverId) {
						if it.Name != "" {
							srv = append(srv, it)
							break
						}
					}
				}
			}
			if len(srv) > 0 {
				desired[item.ServerId] = srv
			}
		}
	}
	if len(desired) == 0 {
		return
	}

	var sb strings.Builder
	sb.WriteString("Items with reused client ids:\n")
	for id, servers := range desired {
		fmt.Fprintf(&sb, "%d:%v, ", id, servers)
	}
	log.Println(sb.String())
}
