package out

import (
	"fmt"
	"math"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/erexo/gobiassets/in"
)

func SaveMonsters(items []*Item) []*Monster {
	defer LogTime("Monsters")()

	_ = os.MkdirAll(outputDir, 0755)
	f, err := os.OpenFile(path.Join(outputDir, monstersFileName), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	monsterFile := in.ReadMonsterFile()

	itemsByServerId := make(map[uint16]*Item)
	for _, item := range items {
		itemsByServerId[item.ServerId] = item
	}
	monsters := make(map[MonsterCategory][]*Monster)
	variables := make(map[*Monster]string)
	var variableChars int
	for cat, dir := range map[MonsterCategory]string{
		MonsterCategoryMonsters: "exp",
		MonsterCategoryBosses:   "bosses",
		MonsterCategorySaga:     "saga",
	} {
		input := in.ReadMonsters(dir)
		mon := make([]*Monster, len(input))
		for i, monster := range input {
			meta := monsterFile[monster.Path]
			m := GetMonster(meta.Id, monster, itemsByServerId)
			mon[i] = m
			variables[m] = meta.Name
			varName := Variable(meta.Name)
			if len(varName) > variableChars {
				variableChars = len(varName)
			}
		}
		sort.Sort(monsterByLevel(mon))
		monsters[cat] = mon
	}

	variableChars++

	var ret []*Monster

	// categories
	var categoriesStr strings.Builder
	for cat := MonsterCategoryFirst; cat <= MonsterCategoryLast; cat++ {
		categoriesStr.WriteString(fmt.Sprintf("\tMonsterCategory(%d): {", cat))
		if monsters, ok := monsters[cat]; ok {
			if len(monsters) > 0 {
				categoriesStr.WriteByte('\n')
			}
			for _, monster := range monsters {
				ret = append(ret, monster)
				categoriesStr.WriteString("\t\t")
				categoriesStr.WriteString(Variable(variables[monster]))
				categoriesStr.WriteString(",\n")
			}
			if len(monsters) > 0 {
				categoriesStr.WriteByte('\t')
			}
		}
		categoriesStr.WriteString("},\n")
	}

	var varStr strings.Builder
	for _, monster := range ret {
		varName := Variable(variables[monster])

		// var
		varStr.WriteString(fmt.Sprintf("\t%s", varName))
		nameDiff := variableChars - len(varName)
		for i := 0; i < nameDiff; i++ {
			varStr.WriteByte(' ')
		}
		varStr.WriteString(fmt.Sprintf("= %s\n", monster.String()))
	}
	if _, err := fmt.Fprintf(f, `// Code generated by "gobiassets" using 'go generate'. DO NOT EDIT.

package %s

%s

%s

%s

var (
%s)

var MonstersCategory = map[MonsterCategory][]*Monster{
%s}
`, packageName, MonsterCategoryPrefix(), BossClassPrefix(), MonsterHeader(), varStr.String(), categoriesStr.String()); err != nil {
		panic(err)
	}
	return ret
}

type Monster struct {
	Id                 uint16
	BossClass          BossClass
	Name               string
	Level              uint32
	Health             int32
	Experience         uint64
	Speed              int32
	Armor              uint16
	LookType           uint16
	LookHead           uint8
	LookPrimary        uint8
	LookSecondary      uint8
	LookDetails        uint8
	LookAddon          uint8
	AverageWeaponDPS   float64
	AverageJutsuDPS    float64
	AverageHPS         float64
	AverageLoot        float64
	AverageLootPer1khp float64
	ExpHpRatio         float64
	Loot               []LootItem
}

type LootItem struct {
	Id       uint16
	Chance   float64
	MinCount uint8
	MaxCount uint8
}

func MonsterHeader() string {
	return `type Monster struct {
	Id                 uint16
	BossClass          BossClass
	Name               string
	Level              uint32
	Health             int32
	Experience         uint64
	Speed              int32
	Armor              uint16
	LookType           uint16
	LookHead           uint8
	LookPrimary        uint8
	LookSecondary      uint8
	LookDetails        uint8
	LookAddon          uint8
	AverageWeaponDPS   float64
	AverageJutsuDPS    float64
	AverageHPS         float64
	AverageLoot        float64
	AverageLootPer1khp float64
	ExpHpRatio         float64
	Loot               []LootItem
}

type LootItem struct {
	Id       uint16
	Chance   float64
	MinCount uint8
	MaxCount uint8
}`
}

func GetMonster(id uint16, m *in.Monster, it map[uint16]*Item) *Monster {
	var level uint32
	if flag, ok := m.Flags["level"]; ok {
		lvl, _ := strconv.Atoi(flag)
		level = uint32(lvl)
	}
	bossClass := BossClassNone
	if flag, ok := m.Flags["boss"]; ok {
		switch flag {
		case "regular":
			bossClass = BossClassRegular
		case "daily":
			bossClass = BossClassDaily
		case "mini":
			bossClass = BossClassMini
		}
	}
	lookType, err := strconv.Atoi(strings.Split(m.Look.Type, ";")[0])
	if err != nil {
		panic(err)
	}
	var worth float64
	var items []LootItem
	for _, item := range m.Loot {
		ids := strings.Split(item.Id, ";")
		chance := item.Chance / float64(len(ids))
		for _, idstr := range ids {
			id, err := strconv.Atoi(idstr)
			if err != nil {
				panic(err)
			}
			it, ok := it[uint16(id)]
			if !ok {
				panic(fmt.Sprintf("Unknown item '%d' in monster \"%s\"", id, m.Name))
			}
			if item.MinCount > math.MaxUint8 {
				panic("MinCount")
			}
			if item.MaxCount > math.MaxUint8 {
				panic("MaxCount")
			}
			items = append(items, LootItem{
				Id:       it.ClientId,
				Chance:   chance * 100,
				MinCount: uint8(item.MinCount),
				MaxCount: uint8(item.MaxCount),
			})
			if it.Worth > 0 {
				avgCount := (float64(item.MinCount) + float64(item.MaxCount)) / 2
				worth += chance * float64(it.Worth) * avgCount
			}
		}
	}

	var weaponDps, jutsuDps float64
	for _, stage := range m.Stages {
		stageWeapon, stageJutsu := calculateDmg(stage.Attacks)
		total := stageWeapon + stageJutsu
		if total > weaponDps+jutsuDps {
			weaponDps, jutsuDps = stageWeapon, stageJutsu
		}
	}
	gweapon, gjutsu := calculateDmg(m.Attacks)
	weaponDps += gweapon
	jutsuDps += gjutsu

	var hps float64
	for _, def := range m.Defenses.Defenses {
		chs := def.Chance / (float64(def.Interval) / 1000)
		heal := (float64(def.Min) + float64(def.Max)) / 2
		hps += heal * chs
	}

	return &Monster{
		Id:                 id,
		BossClass:          bossClass,
		Name:               Title(strings.TrimSpace(m.Name)),
		Level:              level,
		Health:             int32(m.Health.Now),
		Experience:         uint64(m.Experience),
		Speed:              int32(m.Speed),
		Armor:              uint16(m.Health.Armor),
		LookType:           uint16(lookType),
		LookHead:           m.Look.Head,
		LookPrimary:        m.Look.Body,
		LookSecondary:      m.Look.Legs,
		LookDetails:        m.Look.Feet,
		LookAddon:          m.Look.Addons,
		AverageWeaponDPS:   weaponDps,
		AverageJutsuDPS:    jutsuDps,
		AverageHPS:         hps,
		AverageLoot:        worth,
		AverageLootPer1khp: worth / float64(m.Health.Now) * 1000,
		ExpHpRatio:         float64(m.Experience) / float64(m.Health.Now),
		Loot:               items,
	}
}

func (m *Monster) String() string {
	var items strings.Builder
	if len(m.Loot) > 0 {
		items.WriteString(`[]LootItem{`)
		for i, item := range m.Loot {
			items.WriteString(fmt.Sprintf("{%d, %.3g, %d, %d}", item.Id, item.Chance, item.MinCount, item.MaxCount))
			if i < len(m.Loot)-1 {
				items.WriteString(", ")
			}
		}
		items.WriteByte('}')
	} else {
		items.WriteString("nil")
	}

	//return fmt.Sprintf(`&Monster{%d, health: %d, exp: %d, ratio: %.3f, arm: %d, [wep: %0.1f, jutsu: %0.1f, ratio: %.3f, sum: %.f], hp: %.2f, loot: %.1f, lootr: %.2f}`,
	//	m.Level, m.Health, m.Experience, m.ExpHpRatio, m.Armor, m.AverageWeaponDPS, m.AverageJutsuDPS, m.AverageWeaponDPS/m.AverageJutsuDPS, m.AverageWeaponDPS+m.AverageJutsuDPS, m.AverageHPS/float64(m.Health)*1000, m.AverageLoot, m.AverageLootPer1khp)

	return fmt.Sprintf(`&Monster{%d, %d, "%s", %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %.1f, %.1f, %.1f, %.1f, %.2f, %.3f, %s}`, m.Id, m.BossClass, m.Name, m.Level, m.Health, m.Experience, m.Speed, m.Armor, m.LookType, m.LookHead, m.LookPrimary, m.LookSecondary, m.LookDetails, m.LookAddon, m.AverageWeaponDPS, m.AverageJutsuDPS, m.AverageHPS, m.AverageLoot, m.AverageLootPer1khp, m.ExpHpRatio, items.String())
}

func calculateDmg(attacks []in.Attack) (weapon float64, jutsu float64) {
	for _, atk := range attacks {
		if atk.DelayType > 1 {
			continue
		}

		chs := atk.Chance / (float64(atk.Interval) / 1000)
		var dmg float64
		if atk.Skill > 0 && atk.Attack > 0 {
			dmg = (float64(atk.Skill)*(float64(atk.Attack)*0.05) + (float64(atk.Attack) * 0.5)) / 2
		} else {
			dmg = -(float64(atk.Min) + float64(atk.Max)) / 2
		}

		dmg *= chs

		if atk.Name == "melee" {
			weapon += dmg
		} else {
			jutsu += dmg
		}
	}
	return
}

type monsterByLevel []*Monster

func (s monsterByLevel) Len() int      { return len(s) }
func (s monsterByLevel) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
func (s monsterByLevel) Less(i, j int) bool {
	if s[i].Level == s[j].Level {
		if s[i].Health == s[j].Health {
			if s[i].Experience == s[j].Experience {
				return s[i].Name < s[j].Name
			}
			return s[i].Experience < s[j].Experience
		}
		return s[i].Health < s[j].Health
	}
	return s[i].Level < s[j].Level
}
